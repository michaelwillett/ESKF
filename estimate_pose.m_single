function [pos, q] = estimate_pose(sensor, K, dx, dy, p_orig, id)
%ESTIMATE_POSE 6DOF pose estimator based on apriltags
%   sensor - struct stored in provided dataset, fields include
%          - is_ready: logical, indicates whether sensor data is valid
%          - rpy, omg, acc: imu readings, you should not use these in this phase
%          - img: uint8, 240x376 grayscale image
%          - id: 1xn ids of detected tags
%          - p0, p1, p2, p3, p4: 2xn pixel position of center and
%                                four corners of detected tags
%            Y
%            ^ P3 == P2
%            | || P0 ||
%            | P4 == P1
%            o---------> X
%   varargin - any variables you wish to pass into the function, could be
%              a data structure to represent the map or camera parameters,
%              your decision. But for the purpose of testing, since we don't
%              know what inputs you will use, you have to specify them in
%              init_script by doing
%              estimate_pose_handle = ...
%                  @(sensor) estimate_pose(sensor,   personal input arguments);
%   pos - 3x1 position of the quadrotor in world frame
%   q   - 4x1 quaternion of the quadrotor [w, x, y, z] where q = w + x*i + y*j + z*k

N = length(sensor.id);
D = zeros(2*N*5,9);
pos = [];
q = [];

if N > 0
    %correct pos
    for i = 1:N
        [c, r] = ind2sub([12 9],find(id == sensor.id(i)));
        d = [sum(dx(1:c-1)) sum(dy(1:r-1))];
        p = K\[[sensor.p0(:,i) sensor.p1(:,i) sensor.p2(:,i) sensor.p3(:,i) sensor.p4(:,i)]; 1 1 1 1 1];

        for j = 1:5
            xq = p(1,j);
            yq = p(2,j);
            wq = 1;
            Xp = (p_orig(j,1) + d(1));
            Yp = (p_orig(j,2) + d(2));
            Wp = 1;
            D(10*(i-1) + 2*(j-1) + 1,:) = [-Xp -Yp -Wp 0 0 0 xq*xq yq*xq wq*xq];
            D(10*(i-1) + 2*(j-1) + 2,:) = [0 0 0 -Xp -Yp -Wp xq*yq yq*yq wq*yq];
        end
    end

    [~, ~, V] = svd(D);
    A = reshape(V(:,end),[3, 3])';

    Hp = A;
    Hp = Hp/Hp(3,3);
    T = Hp(:,3)/norm(Hp(:,1));
    Hp(:,3) = cross(Hp(:,1), Hp(:,2));
    

    ex = pi;
    ez = -pi/4;
    Rz = [cos(ez) -sin(ez) 0; sin(ez) cos(ez) 0; 0 0 1];
    Rx = [1 0 0; 0 cos(ex) -sin(ex); 0 sin(ex) cos(ex)];

    
    [U, ~, V] = svd(Hp);
    R = ((Rz*Rx)*(U*diag([1 1 det(U*V')])*V')')';
    
    pos = R*(Rz*Rz)*(T) - (Rz*Rx)'*[-0.04, 0.0, -0.03]';
        
    phi = acos((trace(R)-1)/2);  
    if sin(phi) ~= 0
        uhat = .5*(R - R')/sin(phi);
    else
        uhat = zeros(3,3);
    end

    u = [uhat(3,2) uhat(1,3) uhat(2,1)];
    q = [cos(phi/2) u*sin(phi/2)];  
end

end
